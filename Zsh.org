#+TITLE: @pablobfonseca's ZSH Configuration
#+PROPERTY: header-args:shell :tangle ./zsh/zshrc :mkdirp yes

* Welcome to my Zsh Config
This file generates [[file:zshrc][zshrc]] file which can be loaded by ZSH at startup.
* envvars
#+begin_src shell :tangle ./zsh/zshenv
  export UNAME_MACHINE=$(/usr/bin/uname -m)
  export UNAME_SYSTEM=$(/usr/bin/uname)
  export PATH="/opt/homebrew/sbin:$PATH"
  export PATH="/opt/homebrew/bin:$PATH"
  export PATH="/usr/local/sbin:$PATH"
  export HISTSIZE=20000
  export SAVEHIST=20000
  export DOTFILES=$HOME/.dotfiles
  export LC_ALL=en_US.UTF-8
  export LANG=en_US.UTF-8
  export CLICOLOR=1
  export HISTTIMEFORMAT="%d/%m/%y %T"
  export EDITOR=nvim
  export BUNDLER_EDITOR=$EDITOR
  export OBJC_DISABLE_INITIALIZE_FORK_SAFETY=YES # for rails
#+end_src
** Go
#+begin_src shell :tangle ./zsh/zshenv
  export GOPATH=$HOME/code/go-workspace

  if [ "$UNAME_MACHINE" = "arm64" ]; then
     export GOROOT=/opt/homebrew/opt/go/libexec
  else
     export GOROOT=/usr/local/opt/go/libexec
  fi

  export GOBIN=$GOPATH/bin
  export PATH=$PATH:$GOPATH/bin
  export PATH=$PATH:$GOROOT/bin
#+end_src
** Haskell
*** envvars
#+begin_src shell :tangle ./zsh/zshenv
  export PATH="$HOME/.local/bin:$PATH"

#+end_src

*** config
#+begin_src shell
  [ -f "$HOME/.ghcup/env" ] && source "$HOME/.ghcup/env" # ghcup-env
#+end_src
* fzf
** envvars
#+begin_src shell :tangle ./zsh/zshenv
  export FZF_DEFAULT_COMMAND='rg --files --no-ignore --hidden --follow --glob "!.git/*"'
  export FZF_DEFAULT_OPTS='--height 40% --layout=reverse --border'
  export FZF_CTRL_T_COMMAND=$FZF_DEFAULT_COMMAND
  export FZF_COMPLETE=1
#+end_src

** config
#+begin_src shell
  [ -f ~/.fzf.zsh ] && source ~/.fzf.zsh
#+end_src

* zsh-syntax-highlighting
#+begin_src shell
  if [ "$UNAME_MACHINE" = "arm64" ]; then
      source /opt/homebrew/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh
  else
      source /usr/local/share/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh
  fi
#+end_src

* Enable completion
#+begin_src shell
autoload -U compinit
compinit
#+end_src
** completions
*** dotfiles
#+begin_src shell
  source $DOTFILES/zsh/completions/_dotfiles_cli
#+end_src

* Edit current line on EDITOR
#+begin_src shell
autoload -z edit-command-line
zle -N edit-command-line
bindkey "^X^E" edit-command-line
#+end_src

* zplug
#+begin_src shell
  export ZPLUG_HOME=$(brew --prefix zplug)
  source $ZPLUG_HOME/init.zsh
#+end_src
** Plugins
#+begin_src shell
  zplug "zsh-users/zsh-autosuggestions"
  zplug "b4b4r07/enhancd"

  # Install plugins if there are plugins that have not been installed
  if ! zplug check --verbose; then
      printf "Install? [y/N]: "
      if read -q; then
          echo; zplug install
      fi
  fi

  # Then, source plugins and add commands to $PATH
  zplug load
#+end_src
* httptoolkit
 This section will be reset each time a HTTP Toolkit terminal is opened
 #+begin_src shell
   if [ -n "$HTTP_TOOLKIT_ACTIVE" ]; then
       # When HTTP Toolkit is active, we inject various overrides into PATH
       export PATH="$HOME/.local/share/httptoolkit-server/client/1.0.2/overrides/path:$PATH"

       if command -v winpty >/dev/null 2>&1; then
           # Work around for winpty's hijacking of certain commands
           alias php=php
           alias node=node
       fi
   fi
 #+end_src

* rvm
#+begin_src shell :tangle ./zsh/zshenv
  # Add RVM to PATH for scripting. Make sure this is the last PATH variable change.
  export PATH="$PATH:$HOME/.rvm/bin"
  export PATH="$HOME/.gem/bin:$PATH"
  export GEM_HOME=$HOME/.gem
  #+end_src

* nvm
** envvars
#+begin_src shell :tangle ./zsh/zshenv
export NVM_DIR="$HOME/.nvm"
#+end_src

** config
#+begin_src shell
  [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"

  autoload -U add-zsh-hook
  load-nvmrc() {
      local node_version="$(nvm version)"
      local nvmrc_path="$(nvm_find_nvmrc)"

      if [ -n "$nvmrc_path" ]; then
          local nvmrc_node_version=$(nvm version "$(cat "${nvmrc_path}")")

          if [ "$nvmrc_node_version" = "N/A" ]; then
              nvm install
          elif [ "$nvmrc_node_version" != "$node_version" ]; then
              nvm use
          fi
      elif [ "$node_version" != "$(nvm version default)" ]; then
          echo "Reverting to nvm default version"
          nvm use default
      fi
  }
  add-zsh-hook chpwd load-nvmrc
  load-nvmrc
#+end_src

* Functions
** search_route
#+begin_src shell
function search_route {
  bin/rails routes | rg $1
}
#+end_src
** vimup
#+begin_src shell
function vimup {
  nvim +NvChadUpdate
}
#+end_src

** bundle_search
#+begin_src shell
  function bundle_search() {
      pattern="$1"; shift
      ag $pattern $(bundle show --paths "$@")
  }
#+end_src

** take
#+begin_src shell
  function take {
      mkdir $1
      cd $1
  }
#+end_src

** rvmlist
#+begin_src shell
  rvmlist() {
      local rb
      rb=$((echo system; rvm list | grep ruby | cut -c 4-) |
               awk '{print $1}' |
               fzf) && rvm use $rb
  }

#+end_src
** nvmlist
#+begin_src shell
  nvmlist() {
      local njs
      njs=$((nvm ls --no-colors --no-alias | cut -c 8-) | awk '{print $1}' | fzf) && nvm use $njs
  }
#+end_src
** branch_clean
#+begin_src shell
  function branch_clean() {
    git checkout master && git branch --merged | grep -v master | xargs git branch -d
  }
#+end_src
** docker functions
#+begin_src shell
  docker_rmi() {
      local image
      image=$(docker images | awk '(NR>1) { print $1 " " $3; }' | fzf) \
          && docker rmi $(cut -d' ' -f2 <<< "$image") --force
  }

  docker_attach() {
      local container
      container=$(docker ps | awk 'NR>1 { print $1 " " $NF; }' | fzf) \
          && docker attach $(cut -d' ' -f1 <<< "$container")
  }

  docker_stop() {
      local container
      container=$(docker ps | awk 'NR>1 { print $1 " " $NF; }' | fzf) \
          && docker stop $(cut -d' ' -f1 <<< "$container")
  }

  dspec() {
      local file
      file=$(find app/spec -type f | fzf | sed 's/app\/spec/spec/') \
          && docker compose exec -it app rspec "$file"
  }

  alias dconsole="docker compose exec -it app rails c"
#+end_src
** rspec
#+begin_src shell
  fspec() {
      local file
      file=$(find spec -type f | fzf) && rspec "$file"
  }
#+end_src

** heic_to_png
#+begin_src shell
alias heic_to_png="magick mogrify -monitor -format png *.HEIC"
#+end_src

** boot
Starts docker machine for upscope
#+begin_src shell
alias boot=". ./setup-machine.sh"
#+end_src

** find_file
#+begin_src shell
  find_file() {
    find . -type f | fzf | xargs nvim
  }

  zle -N find_file
  bindkey "^P" find_file
#+end_src

** history_search
#+begin_src shell
  bindkey "^R" history-incremental-search-backward
#+end_src
* Aliases
#+begin_src shell
  alias path="echo $PATH | tr -s ':' '\n'"
  alias reload!="source ~/.zshrc"
  alias brew_update="brew update && brew upgrade && brew cleanup"
  alias code="cd ~/code && cd"
  alias untar="tar -zxvf"
  alias genpass="openssl rand -base64 20"
  alias st="git st"
  alias check3000="lsof -i :3000"
  alias ls="lsd"
  alias ll="ls -alF"
  alias bs="git bselect"

  # Upscope aliases
  alias docker_app="docker compose exec -it app"
  alias docker_logs="docker compose logs -f"
  alias docker_frontend="docker compose exec -it app-frontend"
  alias app_migrate="docker_app rails db:migrate"
  alias app_console="docker_app rails c"
  alias app_logs="docker_logs app"

  # GH
  alias copilot="gh copilot"
  alias gcs="gh copilot suggest"
  alias gce="gh copilot explain"
#+end_src

* Languages

* 1Password
#+begin_src shell
  eval "$(op completion zsh)"; compdef _op op
#+end_src
* Starship theme
#+begin_src shell
  eval "$(starship init zsh)"
#+end_src
